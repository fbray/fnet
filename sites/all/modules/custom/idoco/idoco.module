<?php
// $Id: idoco.module 1146 2013-12-16 21:17:58Z sogden1 $

/**
 * @file
 * Import external documentation and present in a Drupal context.
 *
 */

// http://simplehtmldom.sourceforge.net/manual.htm
//include_once drupal_get_path('module', 'idoco') . '/simplehtmldom_1_5/simple_html_dom.php';
//updated include statement to point to doc links module, made doc links a dependencies
include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'doc_links') . '/simplehtmldom_1_5/simple_html_dom.php';
//include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'idoco') . '/simplehtmldom_1_5/simple_html_dom.php';

/**
 * Implements hook_permission().
().
 */
function idoco_permission() {
  return array(
    'administer idoco configuration' => array(
      'title' => t('administer idoco configuration'),
      'description' => t('TODO Add a description for \'administer idoco configuration\''),
    ),
  );
}

/**
 * Implements hook_help().
().
 */
function idoco_help($path, $arg) {
  $help = '';
  switch ($path) {
    // Main module help for the module
    case 'admin/help#idoco':
      $help_file = file_get_contents(drupal_get_path('module', 'idoco') . '/idoco.help.html');
      $help = t($help_file, array(
        '!idoco_settings' => l(t('Idoco settings'), 'admin/fnet/idoco'),
        '!installation' => file_get_contents(drupal_get_path('module', 'idoco') . '/INSTALLATION.txt'),
        '!known_issues' => file_get_contents(drupal_get_path('module', 'idoco') . '/KNOWN_ISSUES.txt'),
      ));
      break;
    case 'admin/fnet/idoco':
      //$help = '';
      break;
  }
  return $help;
}

/**
 * Implements hook_menu().
().
 */
function idoco_menu() {
  $items['idoco'] = array(
    'page callback' => 'idoco_view_versions_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['idoco/%'] = array(
    'page callback' => 'idoco_redirect',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['idoco/%/%'] = array(
    'page callback' => 'idoco_converter',
    'page arguments' => array(1, 2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['idoco/%/%/search'] = array(
    'page callback' => 'idoco_search_view',
    'page arguments' => array(1, 2),
    'access arguments' => array('search content'),
    'type' => MENU_CALLBACK,
  );
  $items['idoco/%/%/search/%'] = array(
    'page callback' => 'idoco_search_view',
    'page arguments' => array(1, 2, 4),
    'access arguments' => array('search content'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/fnet/idoco'] = array(
    'title' => 'Idoco',
    'access arguments' => array('administer idoco configuration'),
    'page callback' => 'idoco_admin_versions_page',
    'file' => 'idoco.admin.inc',
    'file path' => drupal_get_path('module', 'idoco'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/fnet/idoco/versions'] = array(
    'title' => 'Versions',
    'description' => "Product/version settings for Idoco module.",
    'page callback' => 'idoco_admin_versions_page',
    'page arguments' => array(4, 5),
    'access arguments' => array('administer idoco configuration'),
    'file' => 'idoco.admin.inc',
    'file path' => drupal_get_path('module', 'idoco'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/fnet/idoco/configure'] = array(
    'title' => 'Configure',
    'description' => "Settings for Idoco module.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('idoco_admin_configuration_form'),
    'access arguments' => array('administer idoco configuration'),
    'file' => 'idoco.admin.inc',
    'file path' => drupal_get_path('module', 'idoco'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/fnet/idoco/flush_cache'] = array(
    'title' => 'Idoco cache flush',
    'description' => "Flush Idoco page cache.",
    'page callback' => '_idoco_flush_cache',
    'access arguments' => array('administer idoco configuration'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_init().
().
 */
function idoco_init() {
  if ((arg(0) == 'idoco') || (arg(2) == 'idoco')) {
    $path = drupal_get_path('module', 'idoco');
    drupal_add_css($path . '/idoco.css');
    drupal_add_js($path . '/idoco.js');
  }
}

/**
 * Implementation of preprocess_page().
 */
function idoco_preprocess_page($variables) {
  if (arg(0) == 'idoco') {
    $variables['template_files'][] = 'page-idoco';
    // Get rid of body classes that cause unwanted CSS
    $strip_classes = array('/one-sidebar/', '/sidebar-right/');
    if (isset($variables['body_classes'])) {
      $variables['body_classes'] = preg_replace($strip_classes, '', $variables['body_classes']);
    }
  }
}

/**
 * Convert filesystem HTML pages into Drupal pages based on the given URL
 */
function idoco_converter($product, $version) {
  global $sections;

  $record = _idoco_get_version_record(0, $product, $version);
  if (!$record) {
    drupal_not_found();
  }

  // Do NOT process files unless they are HTML
  $is_html = preg_match('/\.(html|htm)$/', $_GET['q']);
  if (!$is_html && !is_null(arg(3))) {
    drupal_not_found();
  }

  $caching_enabled = variable_get('cache', 0) && variable_get('idoco_caching', 1);
  $files_dir = variable_get('file_directory_path', NULL);
  $idoco_document_path = $files_dir . '/' . $record->import_location . '/' . $product . '/' . $version;
  $idoco_default_page = $record->home_page;

  // TODO: make sure directory and default page are set, else error
  $args = arg();

  if (is_null($args[3])) {
    $redirect = '/idoco/' . $product . '/' . $version . '/' . $idoco_default_page;
    drupal_goto($redirect);
  }
  else {
    $doc_file = $args[3];
    // the new html files have pluses in place of spaces
    $doc_file = str_replace(' ', '+', $doc_file);

    // convert parens in file name to %28, %29
    //convert percent signs first or they get double converted
    $doc_file = str_replace('%', '%25', $doc_file);
    $doc_file = str_replace('(', '%28', $doc_file);
    $doc_file = str_replace(')', '%29', $doc_file);
    $doc_file = str_replace(',', '%2C', $doc_file);
    $doc_file = str_replace('/', '%2F', $doc_file);
    $section = "/idoco/$product/$version/" . $doc_file;

    $doc_file = $idoco_document_path . '/' . $doc_file;

  }

  // Update documentation if necessary
  //_idoco_updater();

  //process navigation early so that we can use the structure for fixing links
  $idoco_nav = _idoco_navigation($product, $version);
  $section = $sections[$section];
  $settings = array(
    'section' => $section,
  );
  drupal_add_js(array('idoco' => $settings), array('type' => 'setting', 'scope' => JS_DEFAULT));
  // respect global cache setting
  if ($caching_enabled) {
    $cache_id = "idoco:" . $doc_file;
    $cache = cache_get($cache_id);
  }

  if ($cache && isset($cache->data)) {
    $cache = unserialize($cache->data);
    $idoco_title = $cache['title'];
    $idoco_content = $cache['content'];
  }
  else {
    // reset this
    $cache = array();
    if (is_file($doc_file) && is_readable($doc_file)) {
      $idoco_page = file_get_contents($doc_file);
    }
    else {
      watchdog('idoco', __LINE__ . ': Unable to read source HTML file: !file', array('!file' => $doc_file), WATCHDOG_ERROR);
      return t('The content you requested is not currently available.');
    }

    $html = _idoco_tidy($idoco_page);

    $isIndex = preg_match("/$record->index_filename/", $doc_file);

    $dom = new simple_html_dom();
    $dom->load($html);

    if ($isIndex) {
      $idoco_content = $dom->find('div#content div.pageSection', 1);
    }
    else {
      // Page content
      $idoco_content = $dom->find('div#main-content', 0);
    }

    if (!$idoco_content) {
      watchdog('idoco', __LINE__ . ': Unable to identify proper DOM elements: !file', array('!file' => $doc_file), WATCHDOG_ERROR);
      return t('The content you requested is not currently available.');
    }

    if ($isIndex) {
      // skip the page-section-header div
      $child = $idoco_content->children(1);
      $idoco_content = $child->children(0);
      //adjust the path on all of the anchor nodes
      $nodes = $idoco_content->find('a');
      foreach ($nodes as $node) {
        $href = "idoco/$product/$version/" . $node->attr['href'];
        $node->attr['href'] = $href;
      }
    }
    else {
      // remove error divs
      $nodes = $idoco_content->find('div.error');
      foreach ($nodes as $node) {
        $node->outertext = '';
      }

      // fix img links
      $nodes = $idoco_content->find('img[src]');
      foreach ($nodes as $node) {
        $orig = $node->attr['src'];
        // fix path
        $node->attr['src'] = _idoco_path_fixer($orig);
        $node->attr['data-image-src'] = _idoco_path_fixer($orig);
      }

      // add a class to anchor links so we can alter style
      // make javascript links normal hrefs
      $nodes = $idoco_content->find('a');
      foreach ($nodes as $node) {
        $href = $node->attr['href'];
        if ($href == '') {
          $node->class = 'anchor';
        }
        else {
          if (!preg_match('%(http://|https://)%', $href)) {
            $node->attr['href'] = "/idoco/$product/$version/" . $href;
          }
        }
      }

      // Get us out of the <blockquote>
      $idoco_title = $dom->find('title', 0)->plaintext;
      $idoco_title = trim($idoco_title);
      $idoco_content = "\n<!-- BEGIN IDOCO -->\n" . _idoco_tidy($idoco_content->innertext, 'body_content') . "\n<!-- END IDOCO -->\n";

      if ($caching_enabled) {
        $cache['title'] = $idoco_title;
        $cache['content'] = (string) $idoco_content;
        cache_set($cache_id, serialize($cache));
      }
    }
  }

  $breadcrumb[] = l(t('Home'), NULL);
  $breadcrumb[] = l('Idoco', 'idoco');
  if (arg(3)) { // Source file structure is nested only one deep
    $breadcrumb[] = l(arg(3), "idoco/$product/$version/" . arg(3));
  }
  drupal_set_breadcrumb($breadcrumb);

  drupal_set_title($idoco_title);
  $idoco_form = drupal_get_form('idoco_search_box', '', $product, $version);
  $idoco_search = drupal_render($idoco_form);
  $output = '
    <div id="idoco-wrapper" class="OneLinkNoTx">
      <div id="idoco-sidebar">
        <div id="idoco-search">
          ' . $idoco_search . '
        </div>
        <div id="idoco-nav">
          ' . $idoco_nav . '
        </div>
      </div>
      <div id="idoco-content">
        ' . $idoco_content . '
      </div>
      <div style="clear:both;"></div>
    </div>
  ';

  return $output;
}

/**
 * If new documentation has been uploaded, extract it and reset cache
 */
function _idoco_updater($version_id) {
  $record = _idoco_get_version_record($version_id);
  if (!$record) {
    drupal_set_message('Could not read version record', 'warning');
    return FALSE;
  }
  // If files have been updated, clear cache
  $last_update = strtotime($record->last_update);
  $files_dir = variable_get('file_directory_path', NULL);
  $idoco_document_path = $files_dir . '/' . $record->import_location . '/' . $record->product_identifier . '/' . $record->version_identifier;
  $idoco_document_import_file = $files_dir . '/' . $record->import_filename;

  if (file_exists($idoco_document_import_file)) {
    $current_update = filemtime($idoco_document_import_file);
  }
  else {
    drupal_set_message(t('Could not find file :file', array(':file' => $idoco_document_import_file)), 'warning');
    return FALSE;
  }

  switch ($record->idoco_version) {
    case 1:
      if ($current_update > $last_update) {
        $zip = new ZipArchive;
        if ($zip->open($idoco_document_import_file)) {
          $zip->extractTo($idoco_document_path);
          sleep(10); //wait ten seconds for zip extraction to complete
          $zip->close();
          @chmod($idoco_document_import_file, 0666);
          @unlink($idoco_document_import_file);
          cache_clear_all('idoco:', 'cache', TRUE);
          //rebuild the idoco_content table for search indexing
          $result = idoco_preprocess_document_files($version_id);
          if (!$result) {
            return FALSE;
          }
          //rebuild search index
          idoco_update_index();
          $result = db_update('idoco_version')->fields(array(
              'last_update' => date('Y-m-d H:i:s', $current_update),
            ))->condition('vid', $version_id)->execute();
          if (!$result) {
            drupal_set_message(t('Failed to update version record :vid', array(':vid' => $version_id), array('langcode' => 'warning')));
          }
          return TRUE;
        }
        else {
          watchdog('idoco', __LINE__ . ': Error extracting import file (!file) into (!dir).', array(
            '!file' => $idoco_document_import_file,
            '!dir' => $idoco_document_path,
          ), WATCHDOG_WARNING);
          return FALSE;
        }
      }
      break;
    case 2:
      if ($current_update > $last_update) {
        $zip = new ZipArchive;
        if ($zip->open($idoco_document_import_file)) {
          $zip->extractTo($idoco_document_path);
          sleep(10); //wait ten seconds for zip extraction to complete
          $zip->close();
          @chmod($idoco_document_import_file, 0666);
          @unlink($idoco_document_import_file);
          $result = db_update('idoco_version')->fields(array(
              'last_update' => date('Y-m-d H:i:s', $current_update),
            ))->condition('vid', $version_id)->execute();
          if (!$result) {
            drupal_set_message(t('Failed to update version record :vid', array(':vid' => $version_id), array('langcode' => 'warning')));
          }
          return TRUE;
        }
        else {
          watchdog('idoco', __LINE__ . ': Error extracting import file (!file) into (!dir).', array(
            '!file' => $idoco_document_import_file,
            '!dir' => $idoco_document_path,
          ), WATCHDOG_WARNING);
          return FALSE;
        }
      }
      break;
  }
  return FALSE;
}

/**
 * File path fixer
 *
 * Takes a path (image, href, css, whatever) from within documentation pages and
 * adjusts it to work in the context of idoco
 *
 * NOTE: This is currently not designed to handle href changes...
 *
 * This function always returns an absolute path ie (sites/domain/files/etc..)
 * This is so that we bypass the /idoco root path which feeds back into idoco,
 * which we don't want for non html files.
 *
 */
function _idoco_path_fixer($path) {
  $files_dir = variable_get('file_directory_path', NULL);
  $idoco_document_path = $files_dir . '/' . variable_get('idoco_document_path', NULL);
  preg_match('/idoco\/(.*)\//', $_GET['q'], $matches);
  $relative_path = $matches[1];
  $base_path = $idoco_document_path . '/' . $relative_path;

  // The following fixes relative pathnames in the html. We prepend the path
  // to the file to the relative src value.
  $new_filepath = '/' . $base_path . '/' . $path;
  // Get rid of stuff like /path/to/../../file
  $pattern = '/\w+\/\.\.\//';
  while (preg_match($pattern, $new_filepath)) {
    $new_filepath = preg_replace($pattern, '', $new_filepath);
  }

  if (!file_exists(getcwd() . $new_filepath)) {
    //$error_message = "Could not locate file: " . getcwd() . $new_filepath;
    //watchdog('idoco', __LINE__ . ': ' . $error_message, array(), WATCHDOG_ERROR);

    return FALSE;
  }
  else {
    return $new_filepath;
  }
}

/**
 * Generate Idoco navigation
 *
 */
function _idoco_navigation($product, $version) {
  global $sections;
  $cache_id = "idoco:$product:$version:navigation";
  $cache_enabled = variable_get('cache', 0) && variable_get('idoco_caching', 1);
  if ($cache_enabled > 0 && $data = cache_get("idoco:$product:$version:sections")) {
    $sections = $data->data;
  }
  if ($cache_enabled > 0 && $navigation = cache_get($cache_id)) {
    return $navigation->data;
  }
  else {
    $record = _idoco_get_version_record(0, $product, $version);
    $title = '<h2>Contents</h2>';
    $files_dir = variable_get('file_directory_path', NULL);
    $idoco_document_path = $record->import_location;
    $index = $record->index_filename;
    $toc_file = "$files_dir/$idoco_document_path/$product/$version/$index";
    $navigation = '';

    $dom = new simple_html_dom();
    if (file_exists($toc_file)) {
      $dom->load_file($toc_file);
      $dom = $dom->find('div#content div.pageSection', 1);
      // get the ul
      $child = $dom->children(1);
      $dom = $child->children(0);
      //adjust the path on all of the anchor nodes
      $nodes = $dom->find('a');
      foreach ($nodes as $node) {
        $text = $node->innertext;
        $id = _idoco_str2attr($node->attr['href']);
        $href = $node->attr['href'];
        if (!strstr($href, "idoco/$product/$version/")) {
          $href = "/idoco/$product/$version/" . $href;
        }
        $node->attr['href'] = $href;
        $node->attr['id'] = $id;
        $node->attr['class'] = 'idoco-page';
      }
      $sections = array();
      $nodes = $dom->children;
      foreach ($nodes as $node) {
        if ($node->tag == 'ul') {
          $text = $node->find('a', 0)->innertext;
          $node->outertext = '<div><h4 class="top-nav" id="' . _idoco_str2attr($text) . '">' . $text . '</h4>' . $node->outertext . '</div>';
        }
        else {
          $node->outertext = '';
        }
        $anchors = $node->find('a');
        foreach ($anchors as $anchor) {
          $sections[urldecode($anchor->attr['href'])] = $text;
        }
      }
      $navigation .= "\n" . '<div>';
      $navigation .= $title . '<div id="accordion">';
      $navigation .= $dom->innertext;
      $navigation .= "\n</div></div>\n";
    }
    if ($cache_enabled) {
      cache_set($cache_id, $navigation);
      cache_set("idoco:$product:$version:sections", $sections);
    }
    return $navigation;
  }
}

/**
 * Clean up the input HTML.
 *
 * @param $html_in
 *
 * @param $output - part of the page to return. Options are 'html', 'body', 'body_content', 'head'
 */
function _idoco_tidy($html_in, $output = 'html') {
  $document = new tidy();

  $file_encoding = 'utf8';
  $tidy_config = array(
    'hide-comments' => TRUE,
    'tab-size' => 2,
    'output-xhtml' => TRUE,
    'indent' => TRUE,
    'indent-spaces' => 2,
    'wrap' => 240,
    // The 'clean' option will get rid of stuff like <font> and invalid markup
    'clean' => TRUE,
    'newline' => 'LF',
  );

  if ($output == 'body_content') {
    $tidy_config['show-body-only'] = TRUE;
  }

  $document->parseString($html_in, $tidy_config, $file_encoding);

  if ($output == 'body_content') {
    $html = $document;
  }
  else {
    $html = $document->{$output}();
  }

//  if (!empty($document->errorBuffer)) {
//    watchdog('idoco', __LINE__ . ': The following errors or warnings occured: !errors\n', array('!errors' => $document->errorBuffer), WATCHDOG_WARNING);
//  }

  return $html->value;
}

/**
 * Convert a text string to a valid HTML attribute name. Same function exists
 * in idoco.js. Be sure to replicate changes there.
 */
function _idoco_str2attr($string) {
  $string = drupal_html_to_text($string);
  $string = trim($string);
  $string = drupal_strtolower($string);
  $string = decode_entities($string);
  $string = str_replace('%2b', '+', $string);
  //de-double encode
  $string = str_replace('%25', '%', $string);
  $string = preg_replace('/([^a-z0-9])+/', '-', $string);
  $string = 'idoco-' . $string;
  return $string;
}

/**
 *  Flush all idoco content from the page cache
 */
function _idoco_flush_cache() {
  cache_clear_all('idoco:', 'cache', TRUE);
  drupal_set_message('Idoco cache has been flushed.', 'status');
  drupal_goto('admin/fnet/idoco');
}

/**
 * Upadte idoco_content with the contents of uploaded html files. idoco_content is use to provide search functionality
 *
 * @param $version_id - The vid of the version record in idoco_versions
 */
function idoco_preprocess_document_files($version_id) {
  $errors = 0;
  $record = _idoco_get_version_record($version_id);
  $files_dir = variable_get('file_directory_path', NULL);
  $idoco_document_path = $record->import_location . '/' . $record->product_identifier . '/' . $record->version_identifier;
  $index = $record->index_filename;
  $toc_file = $files_dir . '/' . $idoco_document_path . '/' . $index;
  db_delete('idoco_content')
  ->condition('product', $record->product_identifier)
  ->condition('version', $record->version_identifier)
  ->execute();
  //delete the old search index
  $type = "idoco:$record->product_identifier:$record->version_identifier";
  db_delete('search_dataset')
    ->condition('type', $type)
    ->execute();

  db_delete('search_index')
    ->condition('type', $type)
    ->execute();

  variable_del('idoco_cron_last_id');
  $dom = new simple_html_dom();
  if (file_exists($toc_file)) {
    $dom->load_file($toc_file);
    $dom = $dom->find('div#content div.pageSection', 1);
    // get the ul
    $child = $dom->children(1);
    $dom = $child->children(0);
    //
    $nodes = $dom->find('a');
    foreach ($nodes as $node) {
      $node_record = new stdClass();
      $node_record->product = $record->product_identifier;
      $node_record->version = $record->version_identifier;
      $node_record->filename = urldecode($node->attr['href']);
      $node_record->path = "idoco/$record->product_identifier/$record->version_identifier/" . urldecode($node->attr['href']);
      $node_record->indexed = 0;
      $file_path = $files_dir . '/' . $idoco_document_path . '/' . $node_record->filename;
      if (file_exists($file_path)) {
        $doc_dom = new simple_html_dom();
        $doc_dom->load_file($file_path);
        $matches = array();
        //match the characters after the colon e.g. "VPM Help v8.3 : Configuring Packet Capture for Applications"
        $result = preg_match('/\A(.*:\s)(.*)$/m', $doc_dom->find('title', 0)->plaintext, $matches);
        $node_record->title = $matches[2];
        $idoco_content = $doc_dom->find('div#main-content', 0);
        $node_record->content = _idoco_tidy($idoco_content->innertext, 'body_content');
        unset($doc_dom);
        unset($idoco_content);
      }
      else {
        $errors++;
      }
      $result = drupal_write_record('idoco_content', $node_record);
      if (!$result) {
        $errors++;
        watchdog('idoco', 'Error writing to idoco_content' );
      }
    }
  }
  if ($errors > 0) {
    return false;
  }
  else {
    return true;
  }
}

/**
 *  Update the Drupal search data tables from idoco_content.  Mark each record as indexed so that we can resume after
 *  a timeout or failure
 */
function idoco_update_index() {

  $result = db_query("SELECT did, product, version, title, filename, path, indexed, content
                      FROM {idoco_content}
                      WHERE indexed = :indexed
                      ORDER BY did ASC", array(':indexed' => 0));

  // Feed the external information to the search indexer.
  foreach ($result as $data) {
    $text = '<h1>' . check_plain($data->title) . '</h1>' . $data->content;
    $type = "idoco:$data->product:$data->version";
    search_index($data->did, $type, $text);
    $data->indexed = 1;
    drupal_write_record('idoco_content', $data, 'did');
  }
}

/**
 * Search the index for matching keys
 *
 * @param $keys - keys to search for
 * @param $product - product_identifier to identify the correct set of documentation
 * @param $version - version_identifier for same
 * @return array - array of search results
 */
function idoco_document_search($keys, $product, $version) {
  $type = "idoco:$product:$version";
//  $hits = do_search($keys, $type);
  $query = db_select('search_index', 'i')->extend('SearchQuery');
  $query->join('node', 'n', 'n.nid = i.sid');
  $query->searchExpression($keys, $type);
  $hits = $query->execute();

  $results = array();
  // We now have the IDs of the results. Pull each result
  // from the legacy database.
  foreach ($hits as $item) {
    $note = (object)db_query("SELECT * FROM {idoco_content} WHERE did = :did", array(':did' => $item->sid))->fetchObject();
    $results[] = array(
      'link' => url($note->path),
      'type' => t('Note'),
      'title' => $note->title,
      'score' => $item->calculated_score,
      'snippet' => search_excerpt($keys, $note->content),
    );
  }
  return $results;
}

/**
 * Implements hook_menu_alter.  Remove idoco from the default search form.
().
 * @param $items - menu items
 */
function idoco_menu_alter(&$items) {
  unset($items['search/idoco/%menu_tail']);
}

/**
 * Provide form for search function
 * @param $form_state
 * @param null $keys
 * @param null $product
 * @param null $version
 * @return mixed
 */
function idoco_search_box($form, &$form_state, $keys = NULL, $product = NULL, $version = NULL) {
  $form['product'] = array(
    '#type' => 'value',
    '#value' => $product,
  );
  $form['version'] = array(
    '#type' => 'value',
    '#value' => $version,
  );
  $form['keys'] = array(
    '#title' => t('Search User Guide'),
    '#type' => 'textfield',
    '#size' => 15,
    '#default_value' => $keys,
    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),
  );
  $form['submit'] = array(
    '#prefix' => '<div class="submit-button">',
    '#suffix' => '</div>',
    '#type' => 'submit',
    '#value' => t('Search'),
  );
  return $form;
}

/**
 * Submit function for idoco_search_box form
 * @param $form
 * @param $form_state
 */
function idoco_search_box_submit($form, &$form_state) {
  // The search form relies on control of the redirect destination for its
  // functionality, so we override any static destination set in the request,
  // for example by drupal_access_denied() or drupal_not_found()
  // (see http://drupal.org/node/292565).
  if (isset($_GET['destination'])) {
    unset($_GET['destination']);
  }
  if (isset($_REQUEST['edit']['destination'])) {
    unset($_REQUEST['edit']['destination']);
  }
  $product = $form_state['values']['product'];
  $version = $form_state['values']['version'];
  $form_state['redirect'] = "idoco/$product/$version/search/" . trim($form_state['values']['keys']);
}

/**
 * Validate function for idoco_search_box form
 * @param $form
 * @param $form_state
 */
function idoco_search_box_validate($form, &$form_state) {
  $keys = trim($form_state['values']['keys']);
  if (!$keys) {
    form_set_error('keys', t('Please enter some keywords.'));
  }
}

/**
 * Display a page of search results with form for new search
 * @param $product
 * @param $version
 * @param null $keys
 * @return null|string
 */
function idoco_search_view($product, $version, $keys = NULL) {
  // Search form submits with POST but redirects to GET. This way we can keep
  // the search query URL clean as a whistle:
  // search/type/keyword+keyword
  if ($keys) {

    // Only perform search if there is non-whitespace search term:
    $results = '';
    if (trim($keys)) {
      // Log the search keys:
      watchdog('search', '%keys (idoco).', array('%keys' => $keys), WATCHDOG_NOTICE, l(t('results'), "idoco/$product/$version/search/" . $keys));

      // Collect the search results:
      $results = idoco_document_search($keys, $product, $version);
      $results = theme('search_results', array('results' => $results, 'module' => "idoco:$product:$version"));
    }

    // Construct the search form.
    $output = '<div id="results-search-box">';
    $form = drupal_get_form('idoco_search_box', $keys, $product, $version);
    $output .= drupal_render($form);
    $output .= '</div>';
    $output .= $results;

    return $output;
  }
  $idoco_search_form = drupal_get_form('idoco_search_box', empty($keys) ? '' : $keys, $product, $version);
  return drupal_render($idoco_search_form);
}

/**
 * Helper function to retrieve a record.  If product and version are given use those for lookup else up version_id
 * @param $version_id
 * @param null $product
 * @param null $version
 * @return bool|null|object|stdClass - retrieved record as standard object
 */
function _idoco_get_version_record($version_id, $product = NULL, $version = NULL) {
  $sql = 'SELECT vid, product_name, product_identifier, version_name, version_identifier, import_location, ';
  $sql .= 'import_filename, index_filename, home_page, last_update, idoco_version, document_root ';
  $sql .= 'FROM {idoco_version} ';
  if (!is_null($product) && !is_null($version)) {
    $sql .= "WHERE product_identifier = :prod_identifier AND version_identifier = :ver_identifier ";
    $result = db_query($sql, array(
      ":prod_identifier" => $product,
      ":ver_identifier" => $version
    ));
  }
  else {
    $sql .= 'WHERE vid = :vid ;';
    $result = db_query($sql, array(":vid"=>$version_id));
  }
  if (!$result) {
    drupal_set_message('Could not read version record', 'warning');
    return FALSE;
  }
  else {
//    $record = db_fetch_object($result);
    $record = (object)$result->fetchObject();

    if ((($version_id > 0) && ($record->vid <> $version_id)) || 
      (!is_null($product) && ($record->product_identifier <> $product))) {
      drupal_set_message('Could not read version record', 'warning');
      return FALSE;
    }
    return $record;
  }
}

/**
 * display list of available documentation based on records in idoco_versions
 * @return string
 */
function idoco_view_versions_page() {
  $sql = 'SELECT product_name, version_name, product_identifier, version_identifier, document_root, home_page ';
  $sql .= 'FROM {idoco_version} ORDER BY product_identifier ASC, version_identifier ASC';
  $result = db_query($sql);
  $output = '<div id="idoco-versions-page">' . "\n";
  $output .= '<div id="idoco-versions-page-title"><h3>Product Documentation</h3></div>' . "\n";
  $output .= '<div class="idoco-versions-list">' . "\n";
//  while ($record = db_fetch_object($result)) {
  foreach($result as $record) {
    $output .= '<p>' . l($record->product_name . ' - '  . $record->version_name, "$record->document_root/$record->product_identifier/$record->version_identifier/$record->home_page") . '</p>' . "\n";
  }
  $output .= '</div>' . "\n";
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function idoco_redirect($page) {
  $url =  variable_get('idoco_redirect', 'idoco/vpm/v081/');
  if (substr($url, -1) != '/') {
    $url = $url . '/';
  }
  drupal_goto($url . $page);
}
